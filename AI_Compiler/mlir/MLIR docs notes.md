# MLIR notes

## Multi-Level Intermediate Representation Overview

a novel approach to building reusable and extensible compiler infrastructure.

aims to 

- address software fragmentation

- improve compilation for heterogeneous hardware

  >heterogeneous hardware(异构架构)：
  >
  >在同一个计算系统中使用多种不同类型的处理器或计算核心来完成不同的任务。这些处理器或核心可能具有不同的架构、指令集或特性，通常被设计用于处理特定类型的计算任务，以提高性能、能效或灵活性。
  >
  >诸如
  >
  >- CPU与GPU
  >- FPGA
  >- ASIC：专用集成电路，专门未特定应用程序设计的定制集成电路，通常用于高性能、低功耗的特定任务。

- reduce the cost of building DSA compilers and aid in connecting existing compilers together.

## What is MLIR for?

MLIR is intended to be a hybrid IR which can support mulitiple different requirements in a unified infrastructure.

- The ability to represent **dataflow graphs**.
- Optimizations and transformations typically done on such **graphs**.
- Ability to host HPC-style **loop optimizations** across kernels, and to **transform memory layouts of data.**
- Code geenration **lowering transformations** such as DMA insertion
  - explicit cache management
  - memory tiling 
  - vectorization for 1D and 2D register architectures.
- Abaility to represent **target-specific operation**, e.g. accelerator-specific high-level operations.
- **Quantization** and other **graph transformation**s done on a **Deep-Learning graph.**
- polyhedral primitives(多面体优化)
- Hardware Synthesis Tools / HLS

do not try to support low level machine code generation algorithms(like register allocation and instruction scheduling)

They are a better fit for lower level optimizers (such as LLVM). Also, we do not intend MLIR to be a source language that end-users would themselves write kernels in (analogous to CUDA C++)

## Compiler  infrastructure

Other lessons have been incorporated and integrated into the design in subtle ways. For example, LLVM has non-obvious design mistakes that prevent a multithreaded compiler from working on multiple functions in an LLVM module at the same time. MLIR solves these problems by having limited SSA scope to reduce the use-def chains and by replacing cross-function references with explicit [`symbol reference`](https://mlir.llvm.org/docs/LangRef/#symbol-reference-attribute).

## Deprecations & Current Refactoring

### Use the free function variants for `dyn_cast`/`cast`/ `isa`/...

When casting attributes or type, use the free functions variants `dyn_cast<T>(x)`, `isa<T>(x)`

should not use the cast methods variants `x.dyn_cast<T>()`

## Tutorials

### Creating a Dialect

public dialects are typically separated into at least 3 directories

- mlir/include/mlir/Dialect/Foo (for public include files)
- mlir/lib/Dialect/Foo (for sources)
- mlir/lib/Dialect/Foo/IR(for operations)
- mlir/lib/Dialect/Foo/Transforms(for transforms)
- mlir/test/Dialect/Foo (for tests)

>replace Foo with any other name will get a specific Dialect like linalg

Along with other public headers, the 'include' directory contains a TableGen file in the `ODS format`

- describling the operations in the dialects
- generate 
  - operation declarations: FooOps.h.inc
  - operation definitions: FooOps.cpp.inc
  - operation interface declarations: FooOpsInterfaces.h.inc
  - operation interface definitions: FooOpsInterfaces.cpp.inc

The 'IR' directory typically containes implementations of functions for the dialect which are not automatically generated by ODS.

These are typically defined in FooDialect.cpp, which includes FooOps.cpp.inc and FooOpsInterfaces.h.inc

The 'Transforms' directory contains rewrite rules for the dialect, typically described in TableGen file using the `DDR format`

>Note that dialect names should not generally be suffixed with "Ops", although some files pertaining only to the operations of a dialect might be.

#### CMake best pratices

Operations in dialects are typically declared using the ODS format in tablegen in a file FooOps.td. This file forms the core of a dialect and is declared using `add_mlir_dialect()`

```cmake
add_mlir_dialect(FooOps foo)
add_mlir_doc(FooOps FooDialect Dialects/ -gen-dialect-doc)
```

>在 MLIR 项目中添加一个新的方言 (`FooOps`)，并处理它的构建和集成。
>
>生成该方言的文档文件 (`FooDialect.md` 或类似的文件)，该文件将放置在 `Dialects/` 目录中，并包含与该方言相关的详细信息。

This generates the correct rules to run mlir-tblgen, along with a 'MLIRFooOpsIncGen' target which cna be used to declare dependencies.

Dialect transformations are typically declared in a file FooTransforms.td. Targets for TableGen are described in typical llvm fashion

```cmake
set(LLVM_TARGET_DEFINITIONS FooTransforms.td)
mlir_tablegen(FooTransforms.h.inc -gen-rewriters)
add_public_tablegen_target(MLIRFooTransformIncGen)
```

- 将 `FooTransforms.td`文件设置为目标定义文件。该文件通常包含 MLIR 或 LLVM 的TableGen 语法定义，用于定义重写模式、转换或其他与编译器相关的结构
- 这个命令调用了 MLIR 的 mlir-`tblgen`工具，以生成一个包含重写模式的头文件 `FooTransforms.h.inc`。 `-gen-rewriters`参数指定了要生成重写器代码，这是 TableGen 工具的一种生成模式，用于将 `.td`文件中的转换模式 转化为C++代码
- 将生成的目标作为一个公共的 TableGen 目标添加到构建系统中。这样，其他部分的CMake 配置或其他项目都可以引用该目标。这个目标通常在编译时用来生成包含转换实现的头文件。

>设置一个 TableGen 定义文件 (`FooTransforms.td`) 作为目标。
>
>生成一个包含重写模式的头文件 (`FooTransforms.h.inc`)。
>
>将生成的目标 (`MLIRFooTransformIncGen`) 公开，以供其他构建部分引用。

#### Library Targets

Dialects may have multiple libraries. Each library is typically declared with `add_mlir_dialect_library()`. Dialect libraries often depend on the generation of header files from TableGen (specified using the DEPENDS keyword). Dialect libraries may also depend on other dialect libraries. Typically this dependence is declared using `target_link_libraries()` and the PUBLIC keyword. For instance:

```cmake
add_mlir_dialect_library(MLIRFoo
  DEPENDS
  MLIRFooOpsIncGen
  MLIRFooTransformsIncGen

  LINK_COMPONENTS
  Core

  LINK_LIBS PUBLIC
  MLIRBar
  <some-other-library>
  )
```

add_mlir_dialect_library() is a thin wrapper around add_llvm_library() which collects a list of all the dialect libraries. This list is often useful for linking tools (e.g. mlir-opt) which should have access to all dialects. This list is also linked into libMLIR.so. The list can be retrieved from the MLIR_DIALECT_LIBS global property:

```cmake
get_property(dialect_libs GLOBAL PROPERTY MLIR_DIALECT_LIBS)
```

#### Dialect Conversions

Conversions from "X" to "Y" live in 

- mlir/include/mlir/Conversion/XToY
- mlir/lib/Conversion/XToY
- mlir/test/Conversion/XToY

Default file names for conversion should omit "Convert" from their name, e.g. 

- lib/VectorToLLVM/VectorToLLVM.cpp

Conversion passes should live separately from conversions themselves for convenience of users that only care about a pass and not about its implementation with patterns or other infrastructure.

- include/mlir/VectorToLLVM/VectorToLLVMPass.h

Common conversion functionality from or to dialect "X" that does not belong to the dialect definition can be located in mlir/lib/Conversion/XCommon, for example 

`mlir/lib/Conversion/GPUCommon`

##### CMake best practices
